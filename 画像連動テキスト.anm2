--track@whole_posx:全体位置X,-100000,100000,0,1
--track@whole_posy:全体位置Y,-100000,100000,0,1
--track@text_posx:テキスト位置X,-100000,100000,0,1
--track@text_posy:テキスト位置Y,-100000,100000,0,1
--track@wipe_posx:ワイプ位置X,-100000,100000,-100,1
--track@wipe_posy:ワイプ位置Y,-100000,100000,-50,1
--track@wipe_size:ワイプサイズ,-1000,1000,150,1
--select@text_type:テキスト寄せ=5,真ん中[上]=1,左寄せ[上]=2,右寄せ[上]=3,真ん中[中]=4,左寄せ[中]=5,右寄せ[中]=6,真ん中[下]=7,左寄せ[下]=8,右寄せ[下]=9
--track@shapes_size:図形サイズ,-1000,1000,0,1
--color@shapes_col:図形色,0xffffff
--select@shapes_type:図形タイプ=2,背景=1,円=2,四角形=3,三角形=4,五角形=5,六角形=6,星型=7,ハート=8
--track@shapes_frame_size:図形縁取りサイズ,0,500,0,1
--track@shapes_frame_blur:図形縁取りぼかし,0,100,0,1
--color@shapes_frame_col:図形縁取り色,0xc81e1e
--track@image_posx:画像位置X,-100000,100000,0,1
--track@image_posy:画像位置Y,-100000,100000,0,1
--track@image_size:画像サイズ,-1000,1000,0,1
--file@path:画像ファイル
--check@exclusion_text:テキストを後続のエフェクト対象から除外,0
--check@exclusion_wipe:ワイプを後続のエフェクト対象から除外,0
--check@exclusion_image:画像を後続のエフェクト対象から除外,1

obj.copybuffer("cache:text","obj")

-- 背景タイプの文字列を格納するテーブル変数。
-- bg_typeには数値しか入っていないが、loadには文字列を渡す必要があるため。
local shapes_names = {
    [1] = "背景",
    [2] = "円",
    [3] = "四角形",
    [4] = "三角形",
    [5] = "五角形",
    [6] = "六角形",
    [7] = "星型",
    [8] = "ハート"
}

-- bg_typeの数値によって、used_bg_typeに文字列を代入。
-- 前者bg_names[]の判定が真ならorの後は実行されない。何らかの理由で前者が実行されなかった場合だけ後者の"円"が入る。
local used_shapes_type = shapes_names[shapes_type] or "円" -- 円がマスクで使う場合の最も無難な形であると判断したため、ここは"円"としている。
local oz = 0

obj.setoption("drawtarget","tempbuffer",obj.screen_w,obj.screen_h)

-- 1. 図形の描画
obj.load("figure", used_shapes_type, shapes_col, 100)
-- 図形の最終的な表示倍率（1.0 = 100px相当）
local shapes_final_zoom = math.max(0,(shapes_size + wipe_size) / 100)

obj.draw(wipe_posx, wipe_posy, oz, shapes_final_zoom)
-- 2. 画像とマスクの描画
if path ~= 0 then
    obj.load("image", path)
    
    -- 画像自体の描画倍率
    local img_zoom = math.max(0,(image_size + wipe_size) / 100)
    if img_zoom <= 0 then img_zoom = 0.01 end -- 0除算および非表示回避

    -- マスク相対座標の計算
    -- 画像の拡大率(img_zoom)で割ることで、画面上の絶対的な距離を画像内座標に変換する
    local sumx = -image_posx / img_zoom
    local sumy = -image_posy / img_zoom
    
    -- マスクサイズの計算（ここが修正の肝）
    -- 図形は100pxの元データを shapes_final_zoom 倍して描画している。
    -- マスクの「サイズ」は 100 を「元データ(100px)と同じ」と定義しているため、
    -- 単純に (図形の拡大倍率 * 100) / (画像の拡大倍率) で、画像上での見た目のサイズを同期させる。
    local mask_size = (shapes_final_zoom * 100) / img_zoom

    obj.effect("マスク", "X", sumx, "Y", sumy, "回転", 0, "サイズ", mask_size, "マスクの種類", used_shapes_type)
    if exclusion_image == 0 then -- 画像を後続のエフェクト対象から除外するかどうかの判定
        obj.effect()
    end
    obj.draw(image_posx + wipe_posx, image_posy + wipe_posy, oz, img_zoom)
end


obj.setoption("drawtarget","framebuffer")
obj.load("tempbuffer")

obj.effect("縁取り","サイズ",shapes_frame_size,"ぼかし",shapes_frame_blur,"縁色",shapes_frame_col)

if exclusion_wipe == 0 then --ワイプ全体を後続のエフェクト対象から除外するかどうかの判定
    obj.effect()
end
obj.draw(whole_posx,whole_posy)

obj.copybuffer("obj","cache:text")

local w, h = obj.getpixel()

-- テーブル構造: {cx係数, ox係数, cy係数, oy係数}
local aligns = {
    [1] = { 0.0,  0.0,  0.0,  0.5}, -- 真ん中[上]
    [2] = { 0.0,  0.5,  0.0,  0.5}, -- 左寄せ[上]
    [3] = { 0.5,  0.0,  0.0,  0.5}, -- 右寄せ[上]
    
    [4] = { 0.0,  0.0,  0.0,  0.0}, -- 真ん中[中]
    [5] = { 0.0,  0.5,  0.0,  0.0}, -- 左寄せ[中]
    [6] = { 0.5,  0.0,  0.0,  0.0}, -- 右寄せ[中]
    
    [7] = { 0.0,  0.0,  0.5,  0.0}, -- 真ん中[下]
    [8] = { 0.0,  0.5,  0.5,  0.0}, -- 左寄せ[下]
    [9] = { 0.5,  0.0,  0.5,  0.0}  -- 右寄せ[下]
}

local a = aligns[text_type] or aligns[5]

local cx,cy = w,h
local ox,oy = w,h

if aligns[text_type] == 1 then
    ox = w * -1
elseif aligns[text_type] == 2 then
    -- この場合は処理をしない。
elseif aligns[text_type] == 3 then
    -- この場合は処理をしない。
elseif aligns[text_type] == 4 then
    -- この場合は処理をしない。
elseif aligns[text_type] == 5 then
    ox = w * -1
elseif aligns[text_type] == 6 then
    cx = w * -1
elseif aligns[text_type] == 7 then
    -- この場合は処理をしない。
elseif aligns[text_type] == 8 then
    ox = w * -1
elseif aligns[text_type] == 9 then
    cx = w * -1
end

-- 共通計算式への代入
obj.cx = cx * a[1] + text_posx
obj.ox = ox * a[2] + text_posx
obj.cy = cy * a[3] + text_posy
obj.oy = oy * a[4] + text_posy

if exclusion_text == 0 then -- テキストを後続のエフェクト対象から除外するかどうかの判定
    obj.effect()
end
obj.draw(text_posx+whole_posx-430,text_posy+whole_posy)